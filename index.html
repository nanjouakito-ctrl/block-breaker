<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>ブロック崩し</title>
<style>
body {
    margin: 0;
    background: #111;
    color: white;
    text-align: center;
    font-family: sans-serif;
}
canvas {
    display: block;
    margin: 0 auto;
    max-width: 100%;
    height: auto;
    touch-action: none;
}
#message {
    margin: 10px;
    font-size: 18px;
}
</style>
</head>
<body>

<h1>ブロック崩し</h1>
<canvas id="game"></canvas>
<div id="message"></div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const message = document.getElementById('message');

// ===== ステージ画像 =====
const stageImages = [
    'stage1.jpg',
    'stage2.jpg',
    'stage3.jpg'
];

let bgImg = new Image();
let coverImg = new Image();

// ===== ゲーム状態 =====
let stage = 0;
let gameStarted = false;
let gameOver = false;
let gameClear = false;

let lives = 3;
const CLEAR_RATE = 0.95;

// ===== パドル =====
const paddle = {
    w: 80,
    h: 12,
    x: 0,
    y: 0,
    speed: 7
};

// ===== ボール =====
const ball = {
    x: 0,
    y: 0,
    r: 6,
    vx: 0,
    vy: 0
};

function resetBall() {
    ball.x = canvas.width / 2;
    ball.y = paddle.y - 20;
    ball.vx = 3 * (Math.random() < 0.5 ? -1 : 1);
    ball.vy = -3;
}

// ===== ブロック =====
let rows = 4;
let cols = 8;
let bw, bh;
let blocks = [];
let brokenBlocks = 0;
let totalBlocks = 0;

// ===== 覆いキャンバス =====
const coverCanvas = document.createElement('canvas');
const coverCtx = coverCanvas.getContext('2d');

// ===== ステージ初期化 =====
function loadStage() {
    gameStarted = false;
    brokenBlocks = 0;

    bgImg = new Image();
    bgImg.src = stageImages[stage];

    coverImg = new Image();
    coverImg.src = stage === 0 ? stageImages[0] : stageImages[stage - 1];

    Promise.all([
        new Promise(r => bgImg.onload = r),
        new Promise(r => coverImg.onload = r)
    ]).then(() => {
        canvas.width = bgImg.width;
        canvas.height = bgImg.height;
        coverCanvas.width = bgImg.width;
        coverCanvas.height = bgImg.height;

        paddle.y = canvas.height - 20;
        paddle.x = (canvas.width - paddle.w) / 2;

        const blockAreaHeight = canvas.height * 0.3;
        bw = canvas.width / cols;
        bh = blockAreaHeight / rows;

        blocks = [];
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                blocks.push({
                    x: x * bw,
                    y: y * bh,
                    alive: true
                });
            }
        }

        totalBlocks = blocks.length;

        coverCtx.clearRect(0, 0, canvas.width, canvas.height);
        coverCtx.drawImage(coverImg, 0, 0);

        resetBall();
        draw();
        message.textContent = `STAGE ${stage + 1}`;
    });
}

// ===== 入力 =====
let left = false;
let right = false;

document.addEventListener('keydown', e => {
    if (e.code === 'Space') startGame();
    if (!gameStarted) return;
    if (e.key === 'ArrowLeft') left = true;
    if (e.key === 'ArrowRight') right = true;
});
document.addEventListener('keyup', e => {
    if (e.key === 'ArrowLeft') left = false;
    if (e.key === 'ArrowRight') right = false;
});

// タッチ
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    startGame();
    movePaddle(e);
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    movePaddle(e);
}, { passive: false });

function movePaddle(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.touches[0].clientX - rect.left;
    paddle.x = Math.max(0, Math.min(canvas.width - paddle.w, x - paddle.w / 2));
}

// ===== ゲーム開始 =====
function startGame() {
    if (gameOver || gameClear) return;
    if (gameStarted) return;
    gameStarted = true;
    message.textContent = '';
    loop();
}

// ===== 更新 =====
const MAX_ANGLE = Math.PI / 3;

function update() {
    if (left) paddle.x -= paddle.speed;
    if (right) paddle.x += paddle.speed;
    paddle.x = Math.max(0, Math.min(canvas.width - paddle.w, paddle.x));

    ball.x += ball.vx;
    ball.y += ball.vy;

    if (ball.x < ball.r || ball.x > canvas.width - ball.r) ball.vx *= -1;
    if (ball.y < ball.r) ball.vy *= -1;

    // パドル反射
    if (
        ball.y + ball.r > paddle.y &&
        ball.x > paddle.x &&
        ball.x < paddle.x + paddle.w &&
        ball.vy > 0
    ) {
        const center = paddle.x + paddle.w / 2;
        const ratio = (ball.x - center) / (paddle.w / 2);
        const angle = ratio * MAX_ANGLE;
        const speed = Math.hypot(ball.vx, ball.vy);
        ball.vx = speed * Math.sin(angle);
        ball.vy = -speed * Math.cos(angle);
    }

    // ブロック衝突
    blocks.forEach(b => {
        if (!b.alive) return;
        if (
            ball.x > b.x &&
            ball.x < b.x + bw &&
            ball.y > b.y &&
            ball.y < b.y + bh
        ) {
            b.alive = false;
            brokenBlocks++;
            ball.vy *= -1;
            coverCtx.clearRect(b.x, b.y, bw, bh);

            if (brokenBlocks / totalBlocks >= CLEAR_RATE) {
                stage++;
                gameStarted = false;
                if (stage >= stageImages.length) {
                    gameClear = true;
                    message.textContent = 'ALL STAGE CLEAR!';
                } else {
                    loadStage();
                }
            }
        }
    });

    // 落下
    if (ball.y > canvas.height) {
        lives--;
        gameStarted = false;
        if (lives <= 0) {
            gameOver = true;
            message.textContent = 'GAME OVER';
        } else {
            resetBall();
        }
    }
}

// ===== 描画 =====
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 背景
    ctx.drawImage(bgImg, 0, 0);

    // ブロック覆い
    ctx.drawImage(coverCanvas, 0, 0);

    // 半透明オーバーレイ（壊れていないブロック）
    ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
    blocks.forEach(b => {
        if (b.alive) {
            ctx.fillRect(b.x, b.y, bw, bh);
        }
    });

    // パドル
    ctx.fillStyle = 'white';
    ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);

    // ボール
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillText(`LIFE: ${lives}`, 10, canvas.height - 10);

    if (!gameStarted) {
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.font = '24px sans-serif';

        if (gameOver) ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
        else if (gameClear) ctx.fillText('GAME CLEAR!', canvas.width / 2, canvas.height / 2);
        else ctx.fillText('TAP or PRESS SPACE', canvas.width / 2, canvas.height / 2);
    }
}

// ===== ループ =====
function loop() {
    if (!gameStarted) {
        draw();
        return;
    }
    update();
    draw();
    requestAnimationFrame(loop);
}

// ===== 開始 =====
loadStage();
</script>

</body>
</html>
