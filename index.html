<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>ブロック崩し</title>
<style>
body {
    margin: 0;
    background: #111;
    color: white;
    text-align: center;
    font-family: sans-serif;
}

canvas {
    display: block;
    margin: 0 auto;
    max-width: 100%;
    height: auto;
    touch-action: none;
}

#downloads {
    display: none;
    margin: 10px;
}

a {
    color: #7cf;
}
</style>
</head>
<body>

<h1>ブロック崩し</h1>
<canvas id="game"></canvas>

<div id="downloads">
    <a href="background.jpg" download>背景画像をダウンロード</a> |
    <a href="cover.png" download>ブロック画像をダウンロード</a>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// ===== 画像 =====
const bgImg = new Image();
bgImg.src = 'background.jpg';

const coverImg = new Image();
coverImg.src = 'cover.png';

// ===== 状態 =====
let gameStarted = false;
let gameOver = false;
let gameClear = false;

let lives = 3;
const CLEAR_RATE = 0.95;

// ===== パドル =====
const paddle = {
    w: 80,
    h: 12,
    x: 0,
    y: 0,
    speed: 7
};

// ===== ボール =====
const ball = {
    x: 0,
    y: 0,
    r: 6,
    vx: 0,
    vy: 0
};

function resetBall() {
    ball.x = canvas.width / 2;
    ball.y = paddle.y - 20;
    ball.vx = 3 * (Math.random() < 0.5 ? -1 : 1);
    ball.vy = -3;
}

// ===== ブロック =====
let rows = 4;
let cols = 8;
let bw, bh;
let blocks = [];
let totalBlocks = 0;
let brokenBlocks = 0;

// ===== 覆いキャンバス =====
const coverCanvas = document.createElement('canvas');
const coverCtx = coverCanvas.getContext('2d');

function initCover() {
    coverCtx.clearRect(0, 0, canvas.width, canvas.height);
    coverCtx.drawImage(coverImg, 0, 0);
}

// ===== レイアウト初期化 =====
function initGameLayout() {
    // canvasサイズを画像に合わせる
    canvas.width = bgImg.width;
    canvas.height = bgImg.height;
    coverCanvas.width = bgImg.width;
    coverCanvas.height = bgImg.height;

    // パドル
    paddle.y = canvas.height - 20;
    paddle.x = (canvas.width - paddle.w) / 2;

    // ブロック
    const blockAreaHeight = canvas.height * 0.3;
    bw = canvas.width / cols;
    bh = blockAreaHeight / rows;

    blocks = [];
    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            blocks.push({
                x: x * bw,
                y: y * bh,
                alive: true
            });
        }
    }

    totalBlocks = blocks.length;
    brokenBlocks = 0;

    resetBall();
}

// ===== 入力（キーボード） =====
let left = false;
let right = false;

document.addEventListener('keydown', e => {
    if (e.code === 'Space') {
        startGame();
    }
    if (!gameStarted) return;
    if (e.key === 'ArrowLeft') left = true;
    if (e.key === 'ArrowRight') right = true;
});

document.addEventListener('keyup', e => {
    if (e.key === 'ArrowLeft') left = false;
    if (e.key === 'ArrowRight') right = false;
});

// ===== 入力（タッチ） =====
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    startGame();
    movePaddleByTouch(e);
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    movePaddleByTouch(e);
}, { passive: false });

function movePaddleByTouch(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.touches[0].clientX - rect.left;
    paddle.x = x - paddle.w / 2;
    paddle.x = Math.max(0, Math.min(canvas.width - paddle.w, paddle.x));
}

// ===== ゲーム開始処理 =====
function startGame() {
    if (gameStarted) return;

    if (gameOver || gameClear) {
        lives = 3;
        gameOver = false;
        gameClear = false;
        blocks.forEach(b => b.alive = true);
        brokenBlocks = 0;
        initCover();
        document.getElementById('downloads').style.display = 'none';
    }

    gameStarted = true;
    loop();
}

// ===== 更新 =====
const MAX_ANGLE = Math.PI / 3;

function update() {
    if (left) paddle.x -= paddle.speed;
    if (right) paddle.x += paddle.speed;
    paddle.x = Math.max(0, Math.min(canvas.width - paddle.w, paddle.x));

    ball.x += ball.vx;
    ball.y += ball.vy;

    // 壁
    if (ball.x < ball.r || ball.x > canvas.width - ball.r) ball.vx *= -1;
    if (ball.y < ball.r) ball.vy *= -1;

    // パドル反射
    if (
        ball.y + ball.r > paddle.y &&
        ball.x > paddle.x &&
        ball.x < paddle.x + paddle.w &&
        ball.vy > 0
    ) {
        const center = paddle.x + paddle.w / 2;
        const ratio = (ball.x - center) / (paddle.w / 2);
        const angle = ratio * MAX_ANGLE;
        const speed = Math.hypot(ball.vx, ball.vy);

        ball.vx = speed * Math.sin(angle);
        ball.vy = -speed * Math.cos(angle);
    }

    // ブロック衝突
    blocks.forEach(b => {
        if (!b.alive) return;
        if (
            ball.x > b.x &&
            ball.x < b.x + bw &&
            ball.y > b.y &&
            ball.y < b.y + bh
        ) {
            b.alive = false;
            brokenBlocks++;
            ball.vy *= -1;
            coverCtx.clearRect(b.x, b.y, bw, bh);

            if (brokenBlocks / totalBlocks >= CLEAR_RATE) {
                gameClear = true;
                gameStarted = false;
                document.getElementById('downloads').style.display = 'block';
            }
        }
    });

    // 落下
    if (ball.y > canvas.height) {
        lives--;
        gameStarted = false;
        if (lives <= 0) {
            gameOver = true;
        } else {
            resetBall();
        }
    }
}

// ===== 描画 =====
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(bgImg, 0, 0);
    ctx.drawImage(coverCanvas, 0, 0);

    ctx.fillStyle = 'white';
    ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);

    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillText(`LIFE: ${lives}`, 10, canvas.height - 10);

    if (!gameStarted) {
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.font = '24px sans-serif';

        if (gameClear) ctx.fillText('GAME CLEAR', canvas.width / 2, canvas.height / 2);
        else if (gameOver) ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
        else ctx.fillText('TAP or PRESS SPACE', canvas.width / 2, canvas.height / 2);
    }
}

// ===== ループ =====
function loop() {
    if (!gameStarted) {
        draw();
        return;
    }
    update();
    draw();
    requestAnimationFrame(loop);
}

// ===== 初期化 =====
Promise.all([
    new Promise(r => bgImg.onload = r),
    new Promise(r => coverImg.onload = r)
]).then(() => {
    initGameLayout();
    initCover();
    draw();
});
</script>

</body>
</html>
